改动清单（直接复制）
1) 在 gen_bicycle_dual_vis.py 顶部 import 引擎

在现有 import 区域加一行（位置不限，只要在使用前）：

from engine_builtin import EngineCfg, generate_route as gen_engine

2) 用引擎重写 bicycle_traj(...) 函数

在 gen_bicycle_dual_vis.py 里找到你现在的 bicycle_traj(T, dt, seed, ...)（它内部是用正弦造 yaw_rate 和 a_lon 的那段），把整个函数替换为下面这一版。函数签名和返回值完全保持一致（simulate_imu() 无需改）：

def bicycle_traj(
    T: int, dt: float, seed: int,
    use_slip: bool = True, use_gravity: bool = True, use_roll_pitch: bool = True,
    bank_gain: float = 1.0, pitch_gain: float = 1.0,
    **kw
):
    """
    以 engine_builtin.py 生成真实/连贯的车辆轨迹，并映射到 IMU 真值（body frame）与 roll/pitch 代理。
    返回值与旧实现保持一致：acc_true, gyr_true, a_var, g_var, roll, pitch, speed
    """
    import numpy as np
    rng = np.random.default_rng(seed)

    # === 1) 调引擎生成路况 ===
    # 你也可以把这些参数做成 CLI / 配置，此处给出合理默认
    eng_cfg = EngineCfg(
        dt=dt, T=T, seed=seed,
        v_max=kw.get("eng_v_max", 20.0),       # m/s
        a_lon_max=kw.get("eng_a_lon_max", 2.5),
        a_lat_max=kw.get("eng_a_lat_max", 4.0),
        delta_max=kw.get("eng_delta_max", 0.5),       # ~28.6°
        ddelta_max=kw.get("eng_ddelta_max", 0.6),     # rad/s
        tau_delta=kw.get("eng_tau_delta", 0.25),
        sigma_max=kw.get("eng_sigma_max", 0.30),
        jerk_lat_max=kw.get("eng_jerk_lat_max", 6.0),
        grade_std=kw.get("eng_grade_std", 0.01),
    )
    route = gen_engine(eng_cfg)  # dict: t,x,y,z,yaw,v,kappa,a_lat,a_lon,jerk

    # === 2) 提取真值并构造 IMU 量 ===
    yaw = route["yaw"].astype(np.float32)           # 航向（世界系）
    v   = route["v"].astype(np.float32)             # 速度
    a_lon = route["a_lon"].astype(np.float32)       # 纵向加速度（世界->此处当作车体系 x）
    a_lat = route["a_lat"].astype(np.float32)       # 横向加速度（世界->此处当作车体系 y）

    # 真值陀螺：仅 z 轴（平面运动假设）
    yaw_rate = np.diff(yaw, prepend=yaw[:1]) / dt
    gyr_true = np.stack([
        np.zeros_like(yaw_rate, dtype=np.float32),
        np.zeros_like(yaw_rate, dtype=np.float32),
        yaw_rate.astype(np.float32)
    ], axis=-1)

    # 真值加计（先不含重力；稍后按需减重力投影）
    ax = a_lon
    ay = a_lat
    az = np.zeros_like(ax, dtype=np.float32)
    acc_true = np.stack([ax, ay, az], axis=-1).astype(np.float32)

    # roll/pitch 代理：由横/纵向加速度估计（小角近似）
    g = 9.81
    roll  = (bank_gain  * (a_lat / g)).astype(np.float32)   # 左右倾角 ~ 侧向加速度/g
    pitch = (-pitch_gain * (a_lon / g)).astype(np.float32)  # 俯仰 ~ 纵向加速度/g（前加速为低头）

    if use_gravity:
        # 将重力从 body 加速度中扣除：body系下的重力投影（小角近似下也可）
        c_r, s_r = np.cos(roll), np.sin(roll)
        c_p, s_p = np.cos(pitch), np.sin(pitch)
        gx_b = -g * s_p
        gy_b =  g * s_r
        gz_b =  g * (c_p * np.cos(roll))  # 小角可近似为 g
        grav = np.stack([gx_b, gy_b, gz_b], axis=-1).astype(np.float32)
        acc_true = acc_true - grav

    # === 3) 传感器噪声方差轨迹（保持与旧版相近的“随运动强度变化”的日程） ===
    # 你可以替换为原函数里的 schedule；这里给一个稳定且与运动强度相关的示例
    v_eps = np.clip(v / (np.max(v)+1e-6), 0.0, 1.0)
    w_eps = np.clip(np.abs(yaw_rate) / (np.max(np.abs(yaw_rate))+1e-6), 0.0, 1.0)
    a_var = (0.03 + 0.02 * v_eps)**2     # 加计 ~ 速度越快噪声略增
    g_var = (0.002 + 0.002 * w_eps)**2   # 陀螺 ~ 转向越猛噪声略增

    speed = v.astype(np.float32)
    return acc_true, gyr_true, a_var.astype(np.float32), g_var.astype(np.float32), roll, pitch, speed


注：

这个实现严格遵守了旧版 bicycle_traj(...) 的返回 7 元组接口，因此 simulate_imu(...)、视觉端 make_splits(...) 等调用不需要任何修改。

视觉端依旧通过 simulate_imu(...) 里“用无噪声陀螺积分得到 yaw_true，再用 speed 沿该航向积分得到 xy_true”来布置相机位姿，和引擎的 yaw/v 保持一致。

如果你想让视觉端直接用引擎的 x,y 而不是积分复制，可再回到 simulate_imu(...) 里把 xy_true 换成 route['x'],route['y']；当前最小改动不必动那里。

可选（把引擎参数做成配置/命令行）

现在这版把引擎参数写在函数里了。如果你希望像 gen_bicycle_multi.py 那样把引擎参数暴露出来，可以在 argparse 里新增几行，传给 bicycle_traj(..., eng_v_max=..., ...)。例如在 main 里追加：

ap.add_argument("--eng_v_max", type=float, default=20.0)
ap.add_argument("--eng_a_lat_max", type=float, default=4.0)
ap.add_argument("--eng_a_lon_max", type=float, default=2.5)
ap.add_argument("--eng_delta_max", type=float, default=0.5)
ap.add_argument("--eng_ddelta_max", type=float, default=0.6)
ap.add_argument("--eng_tau_delta", type=float, default=0.25)
ap.add_argument("--eng_sigma_max", type=float, default=0.30)
ap.add_argument("--eng_jerk_lat_max", type=float, default=6.0)
ap.add_argument("--eng_grade_std", type=float, default=0.01)


然后在 make_splits(...) 内部调用 simulate_imu(...) 的地方，把这些 args.eng_* 透传给 bicycle_traj(...) 即可。