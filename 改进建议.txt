需要修改的文件：gen_bicycle_dual_vis.py
①【添加】ActiveMap 实现（放在 project_points 上方的工具区即可）
# ==== Active sliding map (dynamic landmarks that follow the camera) ====
class ActiveMap:
    """
    维护一个“活动地标池”：按相机位置/航向，保证走廊里至少有 target_local 个点；
    超出上限就按“最久未见优先 + 远离当前走廊”淘汰。所有地标都有“全局 ID”（持久）。
    """
    def __init__(self, rng, cell_m=10.0, max_points=60000, keep_horizon_frames=60, z_range=(-1.0, 3.0)):
        self.rng = rng
        self.cell_m = float(cell_m)
        self.max_points = int(max_points)
        self.keep_h = int(max(1, keep_horizon_frames))
        self.z_range = z_range

        self.next_id = 0                            # 递增 ID 分配器
        self.pos = {}                               # id -> np.array([x,y,z], float32)
        self.last_seen = {}                         # id -> last frame index (int)
        self.grid = {}                              # (i,j) -> set(ids)

    # ---- 内部小工具 ----
    def _cell_of(self, xy):
        return (int(np.floor(xy[0] / self.cell_m)), int(np.floor(xy[1] / self.cell_m)))

    def _grid_add(self, _id, p):
        key = self._cell_of(p[:2])
        s = self.grid.get(key)
        if s is None:
            s = set()
            self.grid[key] = s
        s.add(_id)

    def _grid_del(self, _id, p):
        key = self._cell_of(p[:2])
        s = self.grid.get(key)
        if s is not None and _id in s:
            s.remove(_id)
            if not s:
                self.grid.pop(key, None)

    def _insert_points(self, P):
        """在当前帧插入一批新点（世界系），返回分配的全局ID数组"""
        ids = np.empty(P.shape[0], np.int32)
        for k, p in enumerate(P):
            _id = self.next_id
            self.next_id += 1
            self.pos[_id] = p.astype(np.float32)
            self.last_seen[_id] = -10**9
            self._grid_add(_id, p)
            ids[k] = _id
        return ids

    def _remove_ids(self, ids):
        for _id in ids:
            p = self.pos.pop(_id, None)
            if p is not None:
                self._grid_del(_id, p)
            self.last_seen.pop(_id, None)

    # ---- 采样：在相机前向走廊内均匀撒点（局部坐标→世界） ----
    def _sample_in_corridor(self, n, pos_xy, yaw, fwd_m, lat_m):
        if n <= 0: return np.zeros((0,3), np.float32)
        xb = self.rng.uniform(0.0,  fwd_m, size=n).astype(np.float32)
        yb = self.rng.uniform(-lat_m, lat_m, size=n).astype(np.float32)
        c, s = np.cos(yaw), np.sin(yaw)
        X = pos_xy[0] + c*xb - s*yb
        Y = pos_xy[1] + s*xb + c*yb
        Z = self.rng.uniform(self.z_range[0], self.z_range[1], size=n).astype(np.float32)
        return np.stack([X, Y, Z], axis=-1).astype(np.float32)

    # ---- 查询：取落在“前向走廊”的 id 列表 ----
    def _query_corridor_ids(self, pos_xy, yaw, fwd_m, lat_m):
        # 先用 AABB 选 cell 候选集合
        # 取一个包含旋转矩形的轴对齐盒：半宽 ~ lat_m + fwd_m
        r = fwd_m + lat_m
        x0, y0 = float(pos_xy[0]), float(pos_xy[1])
        i0 = int(np.floor((x0 - r) / self.cell_m)); i1 = int(np.floor((x0 + r) / self.cell_m))
        j0 = int(np.floor((y0 - r) / self.cell_m)); j1 = int(np.floor((y0 + r) / self.cell_m))
        cand = []
        for i in range(i0, i1+1):
            for j in range(j0, j1+1):
                s = self.grid.get((i,j))
                if s: cand.append(s)
        if not cand:
            return np.zeros((0,), np.int32)
        ids = np.fromiter(set().union(*cand), dtype=np.int32)

        # 精过滤：坐标旋到车体系，保留 0<xb<fwd_m 且 |yb|<lat_m
        if ids.size == 0: return ids
        P = np.stack([self.pos[int(_id)] for _id in ids], axis=0)[:, :2]
        P = P - np.array([x0, y0], np.float32)
        c, s = np.cos(-yaw), np.sin(-yaw)
        xb = c*P[:,0] - s*P[:,1]
        yb = s*P[:,0] + c*P[:,1]
        m = (xb > 0.0) & (xb < fwd_m) & (np.abs(yb) < lat_m)
        return ids[m]

    # ---- 核心接口：确保局部有足够地标，并返回该帧的局部 id 与位置 ----
    def ensure_and_query(self, frame_idx, pos_xy, yaw, fwd_m, lat_m, target_local):
        # 1) 查询已有局部地标
        ids_local = self._query_corridor_ids(pos_xy, yaw, fwd_m, lat_m)
        n_need = max(0, int(target_local) - ids_local.size)

        # 2) 若不足，现采新点（就在当前走廊里），并立即加入
        if n_need > 0:
            Pnew = self._sample_in_corridor(n_need, pos_xy, yaw, fwd_m, lat_m)
            new_ids = self._insert_points(Pnew)
            # 新采的都在走廊里，可以直接并入本帧局部集合
            ids_local = np.concatenate([ids_local, new_ids], axis=0)

        # 3) 更新“被看到”的时间戳
        for _id in ids_local:
            self.last_seen[int(_id)] = frame_idx

        # 4) 超限时做淘汰：先丢掉“不是本帧局部”的最久未见；仍超限就按照 last_seen 从旧到新丢
        n_excess = len(self.pos) - self.max_points
        if n_excess > 0:
            local_set = set(int(x) for x in ids_local.tolist())
            # 候选：所有点里剔除本帧局部
            cand = [(_id, t) for _id, t in self.last_seen.items() if _id not in local_set]
            cand.sort(key=lambda kv: kv[1])  # 最旧在前
            drop = [kv[0] for kv in cand[:n_excess]]
            if drop:
                self._remove_ids(drop)

        # 5) 也可做基于 keep_h 的老化淘汰（离开很久的点）
        old = [ _id for _id, t in self.last_seen.items() if (frame_idx - t) > self.keep_h ]
        if old:
            self._remove_ids(old)

        # 6) 返回 ids_local 与其位置数组
        P_local = np.stack([self.pos[int(_id)] for _id in ids_local], axis=0) if ids_local.size>0 \
                  else np.zeros((0,3), np.float32)
        return ids_local.astype(np.int32), P_local.astype(np.float32)


说明：

keep_horizon_frames 让地标在离开视野后还能存活一段时间，保证帧间 ID 重叠。

采样是直接在“前向走廊”里现采，确保每帧立刻可见；ID 会持久存在，直到被淘汰。

网格索引用 (i,j)->set(ids)，插入/删除 O(1)，查询先 AABB 再精过滤，速度很稳。

②【微调】project_points 支持子集全局 ID（如果你之前已改过，这段可保持）
def project_points(Pw, Rcw, tcw, K, img_wh, noise_px=0.5, rng=None, base_ids=None):
    if rng is None:
        rng = np.random.default_rng(0)
    Pc_all = (Rcw @ Pw.T).T + tcw
    Z = Pc_all[:, 2]
    vis_mask = Z > 0.3
    uv_all = (K @ (Pc_all.T / np.clip(Z, 1e-6, None))).T[:, :2]
    W, H = img_wh
    in_img = (uv_all[:, 0] >= 0) & (uv_all[:, 0] < W) & (uv_all[:, 1] >= 0) & (uv_all[:, 1] < H)
    mask = vis_mask & in_img
    if not np.any(mask):
        return np.zeros((0, 2), np.float32), np.zeros((0,), np.int32), np.zeros((0, 3), np.float32)
    ids_local = np.where(mask)[0]
    ids_global = (base_ids[ids_local] if base_ids is not None else ids_local.astype(np.int32))
    uv_noisy = uv_all[mask] + rng.normal(scale=noise_px, size=(int(mask.sum()), 2)).astype(np.float32)
    return uv_noisy.astype(np.float32), ids_global, Pc_all[mask].astype(np.float32)

③【修改】simulate_vision_from_trajectory(...) 接口与帧循环（启用滑动地图）

把函数签名末尾新增这些参数（默认开启滑动地图），并在内部初始化 ActiveMap：

def simulate_vision_from_trajectory(
    T_cam, t_cam_idx, yaw, roll, pitch, xy, speed, dt_cam,
    K, img_wh, Pw_dummy, noise_px=0.5, outlier_ratio=0.1, min_match=20, seed=0,
    # 时变噪声...
    noise_tau_s=0.4, noise_ln_std=0.30, out_tau_s=0.6,
    burst_prob=0.03, burst_gain=(0.2, 0.6), motion_k1=0.8, motion_k2=0.4, lp_pool_p=3.0,
    # === 新增：真·滑动地图参数 ===
    use_sliding_map=True,
    local_cell_m=10.0,          # 网格大小（m）
    local_fwd_m=120.0,          # 前向走廊长度
    local_lat_m=40.0,           # 横向半宽
    target_local=4000,          # 每帧希望在走廊内至少有多少个地标
    max_points=60000,           # 活动地标上限（全局）
    keep_horizon_s=3.0,         # 老化时间（秒），相机频率下折算成帧数
    pb_desc=None
):
    rng = np.random.default_rng(seed)
    # ...（保留你原有的 噪声OU / 外点率OU / 运动调节 / Rcw/ Kinv 等代码）

    # 相机时刻的位姿与时间参数
    Rcw_all, tcw_all = camera_poses_from_imu(yaw[t_cam_idx], roll[t_cam_idx], pitch[t_cam_idx],
                                             xy[t_cam_idx], z_height=1.2,
                                             R_cb=np.array([[0,-1,0],[0,0,-1],[1,0,0]], np.float32), t_cb=np.zeros(3,np.float32))
    Kinv = np.linalg.inv(K).astype(np.float32)

    # === 初始化滑动地图 ===
    keep_h_frames = int(round(max(1e-3, keep_horizon_s) / dt_cam))
    amap = ActiveMap(rng, cell_m=local_cell_m, max_points=max_points,
                     keep_horizon_frames=keep_h_frames, z_range=(-1.0, 3.0))

    UV, idlists, Pc_list = [], [], []
    frame_iter = tqdm(range(T_cam), desc=pb_desc, leave=False) if pb_desc else range(T_cam)
    xy_cam = xy[t_cam_idx]; yaw_cam_full = yaw[t_cam_idx]

    for k in frame_iter:
        if use_sliding_map:
            ids_subset, P_subset = amap.ensure_and_query(
                frame_idx=k,
                pos_xy=xy_cam[k], yaw=yaw_cam_full[k],
                fwd_m=local_fwd_m, lat_m=local_lat_m,
                target_local=target_local
            )
            if ids_subset.size == 0:
                UV.append(np.zeros((0,2), np.float32))
                idlists.append(np.zeros((0,), np.int32))
                Pc_list.append(np.zeros((0,3), np.float32))
                continue
            uv, ids_global, Pc = project_points(
                P_subset, Rcw_all[k], tcw_all[k], K, img_wh,
                noise_px=noise_px_t[k], rng=rng, base_ids=ids_subset
            )
        else:
            # 兼容旧模式（若你保留了静态 Pw + 查询）
            uv, ids_global, Pc = project_points(
                Pw_dummy, Rcw_all[k], tcw_all[k], K, img_wh,
                noise_px=noise_px_t[k], rng=rng
            )
        UV.append(uv); idlists.append(ids_global); Pc_list.append(Pc)

    # ====== 下面保持你原有的匹配 / Sampson / 特征 X_vis / MASK 的代码 ======
    # （无需改动，只是 idlists 现在是“全局 ID”，帧间 intersect1d 照常工作）
    ...


注意：

我把 Pw 参数名改成 Pw_dummy（在滑动地图模式里它不会被用到）。

其它逻辑（交集匹配、注入外点、E 的计算、X_vis 统计）完全不需要改。

④【替换】one_split(...) 里“生成 Pw + 网格索引 + 调 simulate_vision_from_trajectory”的那段

删除你原来的：

# （原）根据距离估 x_max / density / num_pts / Pw = sample_landmarks(...)
# （原）grid_index = build_xy_grid_index(Pw, cell_m=...)
# （原）simulate_vision_from_trajectory(..., Pw, ..., use_local_map=..., local_index=grid_index, ...)


换成滑动地图调用（把新参数从 vis 段读取，给默认值）：

# --- 读取/给定滑动地图参数（可从 cfg.vis 里读）
cell_m        = float(vis.get("local_cell_m", 10.0))
local_fwd_m   = float(vis.get("local_fwd_m", 120.0))
local_lat_m   = float(vis.get("local_lat_m", 40.0))
target_local  = int(  vis.get("sliding_target_local", 4000))
max_points    = int(  vis.get("sliding_max_points", 60000))
keep_h_s      = float(vis.get("sliding_keep_s", 3.0))

K = np.array([[fx,0,cx],[0,fy,cy],[0,0,1]], np.float32)
dt_cam = cam_step * (1.0 / rate_hz)

# 传入一个空的占位 Pw（不会被使用）
Pw_dummy = np.zeros((0,3), np.float32)

E2_vis, X_vis, M_vis = simulate_vision_from_trajectory(
    T_cam, t_cam_idx, yaw, roll, pitch, xy, speed, dt_cam, K, (img_w,img_h), Pw_dummy,
    noise_px=noise_px, outlier_ratio=outlier_ratio, min_match=min_match, seed=seed_r+999,
    noise_tau_s=noise_tau_s, noise_ln_std=noise_ln_std, out_tau_s=out_tau_s,
    burst_prob=burst_prob, burst_gain=burst_gain, motion_k1=motion_k1, motion_k2=motion_k2, lp_pool_p=lp_pool_p,
    use_sliding_map=True,
    local_cell_m=cell_m, local_fwd_m=local_fwd_m, local_lat_m=local_lat_m,
    target_local=target_local, max_points=max_points, keep_horizon_s=keep_h_s,
    pb_desc=f"{split_name}/route{r} frames ({T_cam})"
)


其他部分（IMU 窗口化、VIS 窗口化、保存 npz、分段统计）不用改。

⑤【可选但建议】把 X_vis[k,0] 设为实际内点数而非“匹配总数”

在你计算 X_vis[k] 那里，把

num_inl = float(M)        # ← 这是原“匹配数”
X_vis[k,0] = num_inl / 500.0


改为

N_inlier_actual = max(1, M - m_out)  # 注：m_out 是你注入的外点数
X_vis[k,0] = float(N_inlier_actual) / 500.0


这样 seg_id 的“inlier_drop”更有语义。

⑥【配置】在 config.yaml 的 vis: 段加上（或保持你的默认）
vis:
  # 相机与窗口...（照旧）
  cam_rate_hz: 20.0
  vis_window: 64
  vis_stride: 32
  min_match: 12         # 想更稳先设 8，看健康度回升后再调回 12

  # 滑动地图（真·C）
  local_cell_m: 10.0
  local_fwd_m: 120.0
  local_lat_m: 40.0
  sliding_target_local: 4000
  sliding_max_points: 60000
  sliding_keep_s: 3.0